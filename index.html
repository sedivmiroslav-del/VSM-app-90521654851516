<!doctype html>
<html lang="sk">
<head>
<meta charset="utf-8"/>
<title>VSM</title>
<style>
:root {
  --green: rgb(0,137,61);
  --grey: rgb(135,135,135);
  --light: rgb(182,186,194);
  --accent: rgb(161,200,97);

  --hdr-h: 64px;
  --side-w: 400px;
  --side-mult: 2;
}
/* dynamicky doplnen√© z JS pri otvorenom paneli: --side-open-w */

* { box-sizing: border-box; }
body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: #222; background: #fff; }

header {
  height: var(--hdr-h);
  padding: 10px;
  background: var(--green);
  color: #fff;
  border-bottom: 3px solid var(--accent);
  position: sticky; top: 0; z-index: 10;
}
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

/* Biely n√°pis v zelenej hlaviƒçke */
.controls .brand {
  font-weight: 700;
  font-size: 18px;
  color: #fff;
  letter-spacing: 0.2px;
  margin-right: 12px;
  text-shadow: 0 1px 1px rgba(0,0,0,0.15);
  white-space: nowrap;
}

/* Tlaƒçidl√° */
.btn {
  font-size: 14px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #d1d5db;
  background: linear-gradient(180deg, #ffffff 0%, #f3f4f6 100%);
  color: #1f2937;
  cursor: pointer;
  line-height: 1.2;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  user-select: none;
  box-shadow: 0 1px 1px rgba(0,0,0,0.06);
  transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.05s ease, border-color 0.2s ease;
}
.btn:hover { background: #ffffff; border-color: #c7ccd4; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
.btn:active { transform: translateY(1px); box-shadow: 0 1px 3px rgba(0,0,0,0.1) inset; }
.btn:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }

/* Ovl√°danie str√°n */
#pageControls input[type="number"] {
  width: 60px; border: 1px solid #d1d5db; border-radius: 8px; background: #ffffff; color: #1f2937; padding: 8px 10px;
}
#pageControls input[type="number"]:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }

/* Skryt√Ω file input */
#fileInput { display: none; }

.sep { width: 1px; height: 28px; background: rgba(255,255,255,0.5); }

#status { margin-left: auto; font-size: 13px; opacity: 0.9; }

/* Layout */
#main {
  height: calc(100vh - var(--hdr-h));
  width: 100vw;
  position: relative;
  background: #fff;
}

/* Viewer */
#viewer {
  position: absolute; left: 0; top: 0; right: 0; bottom: 0;
  overflow: auto; background: #fff; border-top: 1px solid var(--light);
  transition: right 0.2s ease;
}
body.panel-open #viewer { right: var(--side-open-w, calc(var(--side-w) * var(--side-mult))); }
#canvasWrap { position: relative; margin: 0 auto; }
canvas { display: block; max-width: none; }
.hand { cursor: grab; }
.hand.dragging { cursor: grabbing; }
.crosshair { cursor: crosshair; }

/* Markery */
#markerLayer { position: absolute; left: 0; top: 0; pointer-events: none; }
.marker {
  position: absolute; transform: translate(-50%, -50%);
  background: var(--green); color: #fff; font-weight: 700; font-size: 12px;
  border-radius: 50%; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center;
  box-shadow: 0 1px 4px rgba(0,0,0,0.25); pointer-events: auto; cursor: pointer; user-select: none; border: 2px solid #fff;
}
@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(161,200,97,0.7); } 100% { box-shadow: 0 0 0 12px rgba(161,200,97,0); } }
.marker.pulse { animation: pulse 1s ease-out 0s 2; }

/* Boƒçn√Ω panel */
#sidePanel {
  position: fixed; right: 0; top: var(--hdr-h); height: calc(100vh - var(--hdr-h));
  width: min(calc(var(--side-w) * var(--side-mult)), 95vw);
  border-left: 2px solid var(--light); background: #fff; display: flex; flex-direction: column;
  transform: translateX(100%); transition: transform 0.2s ease; box-shadow: -6px 0 12px rgba(0,0,0,0.06); z-index: 20;
}
#sidePanel.open { transform: translateX(0); }

#sideHeader {
  padding: 10px; border-bottom: 2px solid var(--light); background: #f7f8fa;
  display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 5;
}
#tableWrap { flex: 1 1 auto; overflow: auto; background: #fff; }
table { width: 100%; border-collapse: collapse; font-size: 14px; }
thead th {
  position: sticky; top: 0; z-index: 4; background: var(--light); color: #222;
  border-bottom: 2px solid var(--grey); padding: 8px; text-align: left;
}
tbody td { border-bottom: 1px solid #eee; padding: 6px 8px; }
tbody tr:hover td { background: #f9fafb; }
tbody tr.selected td { background: rgba(161,200,97,0.25); }
tbody td[contenteditable="true"] { outline: none; background: #fffdf7; }
td.actions { width: 1%; white-space: nowrap; }

/* Tlaƒçidlo - ƒçerven√Ω kr√≠≈æik */
.iconBtn { padding: 6px 8px; border: none; background: transparent; border-radius: 8px; cursor: pointer; line-height: 1; user-select: none; }
.iconBtn.delete { color: #d11a2a; font-size: 18px; }
.iconBtn.delete:hover { background: #fee; }
.iconBtn.delete:focus { outline: none; box-shadow: 0 0 0 3px rgba(209,26,42,0.25); }

/* Tlaƒçidlo - oko (zobrazi≈• na mape) */
.iconBtn.view { color: var(--green); font-size: 18px; }
.iconBtn.view:hover { background: #eef6e9; }
.iconBtn.view:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); }

/* ---- Panelov√° r√∫ƒçka (≈°√≠pka) ---- */
#panelHandle {
  position: fixed; top: calc(var(--hdr-h) + 50%); transform: translateY(-50%); right: 0; z-index: 25;
  width: 28px; height: 64px; display: inline-flex; align-items: center; justify-content: center;
  background: #f7f8fa; color: #333; border: 2px solid var(--light); border-right: none;
  border-top-left-radius: 10px; border-bottom-left-radius: 10px; box-shadow: -4px 0 8px rgba(0,0,0,0.08);
  cursor: pointer; user-select: none;
}
#panelHandle:hover { background: #fff; }
body.panel-open #panelHandle { right: var(--side-open-w, calc(var(--side-w) * var(--side-mult))); }

/* ---- DOH kalkulaƒçka (mod√°l) ---- */
.modalOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 100; }
.modalOverlay[hidden] { display: none !important; }
.modal { width: min(520px, 92vw); background: #fff; border: 2px solid var(--light); border-radius: 10px; box-shadow: 0 12px 28px rgba(0,0,0,0.18); overflow: hidden; }
.modalHeader { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: #f7f8fa; border-bottom: 2px solid var(--light); }
.modalBody { padding: 12px; display: grid; gap: 12px; }
.field { display: grid; gap: 6px; }
.field.twoCols input { width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 8px; }
.field.twoCols input:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }
.choices { display: flex; gap: 16px; flex-wrap: wrap; }
.actions { display: flex; gap: 8px; }
.result { padding: 10px; background: #f1f8ec; border: 1px solid rgba(0,137,61,0.25); border-radius: 8px; color: #0b5e2a; font-weight: 700; }
.error { color: #b00020; background: #fdecee; border: 1px solid #f5c2c7; border-radius: 8px; padding: 8px 10px; }
.note { color: #555; font-size: 12px; }
</style>
</head>
<body>
<header>
  <div class="controls">
    <span class="brand">Value Stream Management</span>

    <label for="fileInput" class="btn" title="Vybra≈• PDF s√∫bor">Vybra≈• s√∫bor</label>
    <input id="fileInput" type="file" accept=".pdf,application/pdf"/>

    <button id="exportBtn" class="btn" title="Exportova≈• z√°pisn√≠k a markery do JSON">Export</button>
    <button id="importBtn" class="btn" title="Importova≈• z√°pisn√≠k a markery z JSON">Import</button>
    <input id="importDataInput" type="file" accept=".json,application/json" style="display:none"/>

    <button id="addMarkerToggle" class="btn" title="Prida≈• oƒç√≠slovan√Ω marker do PDF">Prida≈• ƒç√≠slo: OFF</button>
    <button id="toggleHand" class="btn">Pan (ruƒçiƒçka): OFF</button>
    <button id="magnifyToggle" class="btn" title="Lupa: ƒæav√Ωm klikom pribl√≠≈æi≈°, prav√Ωm oddiali≈°">Lupa: OFF</button>
    <button id="centerBtn" class="btn" title="Zobrazi≈• cel√© a vycentrova≈•">Vycentrova≈•</button>

    <button id="dohOpen" class="btn" title="Otvori≈• kalkulaƒçku DOH">DOH</button>

    <span class="sep"></span>

    <div id="pageControls">
      <button id="prevBtn" class="btn">Prev</button>
      <span>Strana:</span>
      <input id="pageNum" type="number" min="1" value="1">
      <span>/ <span id="pageCount">0</span></span>
      <button id="nextBtn" class="btn">Next</button>
    </div>

    <div id="status"></div>
  </div>
</header>

<div id="main">
  <div id="viewer">
    <div id="canvasWrap">
      <canvas id="pdfCanvas"></canvas>
      <div id="markerLayer"></div>
    </div>
  </div>

  <aside id="sidePanel">
    <div id="sideHeader">
      <strong style="color:#222;">Z√°pisn√≠k</strong>
      <button id="addRow" class="btn">Prida≈• riadok</button>
      <button id="clearRows" class="btn" title="Vyƒçisti≈• tabuƒæku">Vyƒçisti≈•</button>
      <button id="downloadCsv" class="btn" title="Stiahnu≈• CSV">CSV</button>
    </div>
    <div id="tableWrap">
      <table id="notesTable">
        <thead>
          <tr>
            <th>ƒå√≠slo</th>
            <th>T√©ma</th>
            <th>Zodpovedn√Ω</th>
            <th>Term√≠n</th>
            <th>√öspora</th>
            <th>Projekt</th>
            <th>Status</th>
            <th>Akcie</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </aside>

  <!-- Boƒçn√° r√∫ƒçka (≈°√≠pka) -->
  <button id="panelHandle" title="Zobrazi≈•/Skry≈• z√°pisn√≠k" aria-label="Zobrazi≈•/Skry≈• z√°pisn√≠k" aria-expanded="false">‚Äπ</button>
</div>

<!-- DOH mod√°l -->
<div id="dohOverlay" class="modalOverlay" hidden>
  <div class="modal">
    <div class="modalHeader">
      <strong>DOH kalkulaƒçka</strong>
      <button id="dohClose" class="btn" title="Zavrie≈•">Zavrie≈•</button>
    </div>

    <div class="modalBody">
      <div class="field">
        <label>Dni v obdob√≠:</label>
        <div class="choices">
          <label><input type="radio" name="dohDays" value="30" checked> DOH30 (30 dn√≠)</label>
          <label><input type="radio" name="dohDays" value="360"> DOH360 (360 dn√≠)</label>
        </div>
      </div>

      <div class="field">
        <label>V√Ωsledok v d≈àoch:</label>
        <div class="choices">
          <label><input type="radio" name="dohResultType" value="work" checked> Pracovn√© dni</label>
          <label><input type="radio" name="dohResultType" value="cal"> Kalend√°rne dni</label>
        </div>
      </div>

      <div class="field twoCols">
        <label for="dohWdaysPerWeek">Pracovn√© dni v t√Ω≈ædni (1‚Äì7)</label>
        <input id="dohWdaysPerWeek" type="number" min="1" max="7" value="5" />
        <small class="note">Be≈æne 5; pri 7‚Äëd≈àovej prev√°dzke nastav 7 (pracovn√© = kalend√°rne).</small>
      </div>

      <div class="field twoCols">
        <label for="dohInventory">Hodnota skladu (napr. WIP / z√°soby) [‚Ç¨]</label>
        <input id="dohInventory" type="number" inputmode="decimal" placeholder="napr. 5871000" />
      </div>

      <div class="field twoCols">
        <label for="dohPerfPeriod">V√Ωkon za obdobie (s√∫ƒçet za 30/360 dn√≠) [‚Ç¨]</label>
        <input id="dohPerfPeriod" type="number" inputmode="decimal" placeholder="napr. s√∫ƒçet COGS/COGM za 30/360 dn√≠" />
      </div>

      <div class="actions">
        <button id="dohCalc" class="btn">Vypoƒç√≠ta≈•</button>
        <button id="dohClear" class="btn" title="Vymaza≈• vstupy">Vymaza≈•</button>
      </div>

      <div id="dohResult" class="result">V√Ωsledok: ‚Äî</div>
      <div id="dohError" class="error" hidden></div>
      <div id="dohNote" class="note"></div>
    </div>
  </div>
</div>

<!-- PDF.js kni≈ænica -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<!-- JavaScript je v ƒåasti 2 -->
</body>
</html>
<script>
// PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// DOM elementy
const fileInput = document.getElementById('fileInput');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importDataInput = document.getElementById('importDataInput');

const viewer = document.getElementById('viewer');
const canvasWrap = document.getElementById('canvasWrap');
const canvas = document.getElementById('pdfCanvas');
const ctx = canvas.getContext('2d');
const markerLayer = document.getElementById('markerLayer');

const pageNumInput = document.getElementById('pageNum');
const pageCountEl = document.getElementById('pageCount');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');

const toggleHandBtn = document.getElementById('toggleHand');
const magnifyToggleBtn = document.getElementById('magnifyToggle');
const addMarkerToggleBtn = document.getElementById('addMarkerToggle');
const centerBtn = document.getElementById('centerBtn');

const sidePanel = document.getElementById('sidePanel');
const panelHandleBtn = document.getElementById('panelHandle');
const statusEl = document.getElementById('status');

// Tabuƒæka z√°pisov
const notesTable = document.getElementById('notesTable');
const tbody = notesTable.querySelector('tbody');
const addRowBtn = document.getElementById('addRow');
const clearRowsBtn = document.getElementById('clearRows');
const downloadCsvBtn = document.getElementById('downloadCsv');

const cols = ['ƒå√≠slo','T√©ma','Zodpovedn√Ω','Term√≠n','√öspora','Projekt','Status'];
let rows = [];

// PDF stav
let pdfDoc = null;
let currentPage = 1;
let scale = 1.0;
let fitMode = 'window';
let isHand = false;
let panelOpen = false;
let magnifyOn = false;
let addMarkerOn = false;

const ZOOM_STEP = 1.25;
const FOCUS_SCALE = 2.0;

// ---- Ukladanie PDF: window.name + sessionStorage + localStorage + IndexedDB ----
const PDF_DB_NAME = 'vsmPdfDB';
const PDF_STORE = 'lastPdf';
const PDF_STATE_KEY = 'vsmPdfState';

// window.name payload
const WINDOW_NAME_KEY = 'VSM_PDF_CACHE';

// sessionStorage
const PDF_SESS_DATAURL_KEY = 'vsmPdfDataUrlSess';
const PDF_SESS_NAME_KEY = 'vsmPdfNameSess';

// localStorage (fallback pre men≈°ie PDF)
const PDF_DATAURL_KEY = 'vsmPdfDataUrl';
const PDF_NAME_KEY = 'vsmPdfName';

function openPdfDb() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) return reject(new Error('IndexedDB nie je podporovan√©'));
    const req = indexedDB.open(PDF_DB_NAME, 1);
    req.onupgradeneeded = () => { const db = req.result; if (!db.objectStoreNames.contains(PDF_STORE)) db.createObjectStore(PDF_STORE); };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error || new Error('Nepodarilo sa otvori≈• DB'));
  });
}

async function blobToDataUrl(blob) {
  return await new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = () => reject(fr.error || new Error('FileReader error'));
    fr.readAsDataURL(blob);
  });
}

// Bezpeƒçn√© dek√≥dovanie Data URL bez fetch (Edge + file://)
function dataUrlToArrayBuffer(dataUrl) {
  try {
    const comma = dataUrl.indexOf(',');
    if (comma < 0) return null;
    const meta = dataUrl.slice(0, comma);
    const dataPart = dataUrl.slice(comma + 1);
    const isBase64 = /;base64/i.test(meta);
    let bin;
    if (isBase64) {
      bin = atob(dataPart);
    } else {
      bin = decodeURIComponent(dataPart);
    }
    const len = bin.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  } catch (e) {
    console.warn('Dek√≥dovanie Data URL zlyhalo:', e);
    return null;
  }
}

function saveToWindowName(dataUrl, name) {
  try {
    const payload = { k: WINDOW_NAME_KEY, name, dataUrl };
    window.name = JSON.stringify(payload);
  } catch (e) {
    console.warn('Ukladanie do window.name zlyhalo:', e);
  }
}
function readFromWindowName() {
  try {
    if (!window.name) return null;
    const obj = JSON.parse(window.name);
    if (obj && obj.k === WINDOW_NAME_KEY && obj.dataUrl) {
      const ab = dataUrlToArrayBuffer(obj.dataUrl);
      if (ab) return { name: obj.name || 'PDF', arrayBuffer: ab };
    }
  } catch (e) {
    console.warn('ƒå√≠tanie z window.name zlyhalo:', e);
  }
  return null;
}

async function saveLastPdf(arrayBuffer, name) {
  const blob = new Blob([arrayBuffer], { type: 'application/pdf' });

  // 1) window.name (istota pri refreshi v tom istom tabu)
  try {
    const dataUrl = await blobToDataUrl(blob);
    saveToWindowName(dataUrl, name);
  } catch (e) {
    console.warn('Ukladanie do window.name zlyhalo:', e);
  }

  // 2) sessionStorage (tie≈æ pre≈æije refresh v tom istom tabu)
  try {
    const dataUrl = await blobToDataUrl(blob);
    sessionStorage.setItem(PDF_SESS_DATAURL_KEY, dataUrl);
    sessionStorage.setItem(PDF_SESS_NAME_KEY, name);
  } catch (e) {
    console.warn('Ukladanie do sessionStorage zlyhalo:', e);
  }

  // 3) localStorage (ak sa zmest√≠ ~5MB)
  try {
    const dataUrl = await blobToDataUrl(blob);
    if (dataUrl.length <= 4_800_000) {
      localStorage.setItem(PDF_DATAURL_KEY, dataUrl);
      localStorage.setItem(PDF_NAME_KEY, name);
    } else {
      console.warn('PDF je pr√≠li≈° veƒæk√© pre localStorage fallback.');
    }
  } catch (e) {
    console.warn('Ukladanie do localStorage zlyhalo:', e);
  }

  // 4) IndexedDB (dlh≈°ia perzistencia ‚Äì file:// ju nie v≈ædy povol√≠)
  try {
    const db = await openPdfDb();
    await new Promise((resolve, reject) => {
      const tx = db.transaction(PDF_STORE, 'readwrite');
      tx.oncomplete = () => { db.close(); resolve(); };
      tx.onerror = () => { const err = tx.error || new Error('Tx error'); db.close(); reject(err); };
      tx.objectStore(PDF_STORE).put({ name, data: blob, savedAt: Date.now() }, 'last');
    });
  } catch (e) {
    console.warn('Ukladanie do IndexedDB zlyhalo:', e);
  }
}

async function loadLastPdfRecord() {
  // 1) window.name ‚Äì najspoƒæahlivej≈°ie pri refreshi
  const wn = readFromWindowName();
  if (wn) return wn;

  // 2) sessionStorage
  try {
    const sUrl = sessionStorage.getItem(PDF_SESS_DATAURL_KEY);
    if (sUrl) {
      const ab = dataUrlToArrayBuffer(sUrl);
      if (ab) return { name: sessionStorage.getItem(PDF_SESS_NAME_KEY) || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie zo sessionStorage zlyhalo:', e); }

  // 3) localStorage ‚Äì ak sa zmestilo
  try {
    const lUrl = localStorage.getItem(PDF_DATAURL_KEY);
    if (lUrl) {
      const ab = dataUrlToArrayBuffer(lUrl);
      if (ab) return { name: localStorage.getItem(PDF_NAME_KEY) || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie z localStorage zlyhalo:', e); }

  // 4) IndexedDB ‚Äì ak je dostupn√© na danom p√¥vode
  try {
    const db = await openPdfDb();
    const rec = await new Promise((resolve, reject) => {
      const tx = db.transaction(PDF_STORE, 'readonly');
      tx.oncomplete = () => db.close();
      tx.onerror = () => { const err = tx.error || new Error('Tx error'); db.close(); reject(err); };
      const req = tx.objectStore(PDF_STORE).get('last');
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error || new Error('Get error'));
    });
    if (rec && rec.data) {
      const ab = await rec.data.arrayBuffer();
      return { name: rec.name || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie z IndexedDB zlyhalo:', e); }

  return null;
}

function savePdfState() {
  if (!pdfDoc) return;
  try { localStorage.setItem(PDF_STATE_KEY, JSON.stringify({ page: currentPage, scale, fitMode })); } catch {}
}
function loadPdfState() {
  try { return JSON.parse(localStorage.getItem(PDF_STATE_KEY) || '{}'); } catch { return {}; }
}

// ---- Z√°pisn√≠k (rows) ----
function loadRows() {
  try { const raw = localStorage.getItem('visioNotesRows'); rows = raw ? JSON.parse(raw) : []; }
  catch { rows = []; }
  sortRowsInPlace();
}
function saveRows() { localStorage.setItem('visioNotesRows', JSON.stringify(rows)); }
function sortRowsInPlace() {
  rows.sort((a, b) => {
    const na = parseInt(a['ƒå√≠slo'], 10);
    const nb = parseInt(b['ƒå√≠slo'], 10);
    const aNum = Number.isInteger(na), bNum = Number.isInteger(nb);
    if (aNum && bNum) return na - nb;
    if (aNum && !bNum) return -1;
    if (!aNum && bNum) return 1;
    return 0;
  });
}
function renderRows() {
  sortRowsInPlace(); saveRows();
  tbody.innerHTML = '';
  rows.forEach((r, i) => {
    const tr = document.createElement('tr'); tr.dataset.index = String(i);
    cols.forEach((cKey) => {
      const td = document.createElement('td');
      td.contentEditable = 'true';
      td.textContent = r[cKey] ?? '';
      td.addEventListener('input', () => { rows[i][cKey] = td.textContent; saveRows(); });
      if (cKey === 'ƒå√≠slo') td.addEventListener('blur', () => { sortRowsInPlace(); renderRows(); });
      tr.appendChild(td);
    });

    const tdAct = document.createElement('td'); tdAct.className = 'actions'; tdAct.contentEditable = 'false';

    // Oko (zobrazi≈• na mape)
    const viewBtn = document.createElement('button');
    viewBtn.className = 'iconBtn view';
    viewBtn.title = 'Zobrazi≈• ƒç√≠slo na mape';
    viewBtn.setAttribute('aria-label', 'Zobrazi≈• ƒç√≠slo na mape');
    viewBtn.textContent = 'üëÅ';
    viewBtn.addEventListener('click', () => {
      const num = parseInt(rows[i]['ƒå√≠slo'], 10);
      if (isNaN(num)) {
        statusEl.textContent = 'Riadok nem√° platn√© ƒç√≠slo.';
        return;
      }
      focusMarkerByNumber(num);
    });
    tdAct.appendChild(viewBtn);

    // Kr√≠≈æik (zmaza≈• riadok)
    const delBtn = document.createElement('button'); delBtn.className = 'iconBtn delete';
    delBtn.title = 'Odstr√°ni≈• riadok'; delBtn.setAttribute('aria-label','Odstr√°ni≈• riadok'); delBtn.textContent = '‚úñ';
    delBtn.addEventListener('click', () => {
      const num = parseInt(rows[i]['ƒå√≠slo'], 10);
      rows.splice(i, 1); sortRowsInPlace(); saveRows(); renderRows();
      if (!isNaN(num)) removeMarkerByNumber(num);
    });
    tdAct.appendChild(delBtn);

    tr.appendChild(tdAct);
    tbody.appendChild(tr);
  });
}
function addEmptyRow() { const r = {}; cols.forEach(k => r[k]=''); rows.push(r); sortRowsInPlace(); saveRows(); renderRows(); tbody.lastElementChild?.firstElementChild?.focus(); }
function addRowWithNumber(num) { const r = {}; cols.forEach(k => r[k]=''); r['ƒå√≠slo']=String(num); rows.push(r); sortRowsInPlace(); saveRows(); renderRows(); selectRowByNumber(num); }

// Klik na riadok: iba selektuje riadok, nescrolluje mapu
tbody.addEventListener('click', (e) => {
  const tr = e.target.closest('tr'); if (!tr || e.target.closest('button')) return;
  tbody.querySelectorAll('tr').forEach(r => r.classList.remove('selected')); tr.classList.add('selected');
  // z√°merne nevol√°me focusMarkerByNumber ‚Äì presun rob√≠ len ikona ‚Äûoko‚Äú
});

function selectRowByNumber(num) {
  const i = rows.findIndex(r => parseInt(r['ƒå√≠slo'],10)===num);
  if (i>=0) { const tr = tbody.children[i]; tbody.querySelectorAll('tr').forEach(r => r.classList.remove('selected')); tr?.classList.add('selected'); tr?.scrollIntoView({block:'nearest'}); }
}
addRowBtn.addEventListener('click', addEmptyRow);
clearRowsBtn.addEventListener('click', () => {
  if (!confirm('Naozaj vyƒçisti≈• v≈°etky riadky (a markery)?')) return;
  rows = []; saveRows(); renderRows(); markers = []; saveMarkers(); renderMarkers();
});
downloadCsvBtn.addEventListener('click', () => {
  sortRowsInPlace();
  const csvHeader = [...cols, 'Akcie'].join(';');
  const csvRows = rows.map(r => cols.map(k => (r[k] ?? '').replace(/;/g, ',')).join(';'));
  const csvStr = [csvHeader, ...csvRows].join('\n');
  const blob = new Blob([csvStr], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'zapisnik.csv'; a.click(); URL.revokeObjectURL(url);
});

// ---- Markery ----
let markers = [];
const MARKERS_KEY = 'visioMarkers';
function loadMarkers() { try { const raw = localStorage.getItem(MARKERS_KEY); markers = raw ? JSON.parse(raw) : []; } catch { markers = []; } }
function saveMarkers() { localStorage.setItem(MARKERS_KEY, JSON.stringify(markers)); }
function renderMarkers() {
  markerLayer.innerHTML = ''; markerLayer.style.width = canvas.width + 'px'; markerLayer.style.height = canvas.height + 'px';
  markers.filter(m => m.page===currentPage).forEach(m => {
    const el = document.createElement('div'); el.className='marker'; el.dataset.number=String(m.number); el.textContent=m.number;
    el.style.left = (m.xNorm*canvas.width)+'px'; el.style.top = (m.yNorm*canvas.height)+'px';
    el.addEventListener('click', () => { selectRowByNumber(m.number); setPanelOpen(true); el.classList.add('pulse'); setTimeout(()=>el.classList.remove('pulse'),1200); });
    markerLayer.appendChild(el);
  });
}
function getNextNumber() {
  const used = new Set();
  markers.forEach(m => { const n = parseInt(m.number,10); if (Number.isInteger(n) && n>0) used.add(n); });
  rows.forEach(r => { const n = parseInt(r['ƒå√≠slo'],10); if (Number.isInteger(n) && n>0) used.add(n); });
  let i=1; while(used.has(i)) i++; return i;
}
function removeMarkerByNumber(num) { const before = markers.length; markers = markers.filter(m => m.number!==num); if (markers.length!==before) { saveMarkers(); renderMarkers(); } }
function placeMarkerAtEvent(e) {
  if (e.button!==0) return;
  const rect = canvas.getBoundingClientRect(); const xPx=e.clientX-rect.left; const yPx=e.clientY-rect.top;
  const xNorm = xPx/canvas.width, yNorm = yPx/canvas.height; const num = getNextNumber();
  markers.push({ number:num, page:currentPage, xNorm, yNorm }); saveMarkers(); renderMarkers(); addRowWithNumber(num);
  const mEl = markerLayer.querySelector(`.marker[data-number="${num}"]`); mEl?.classList.add('pulse'); setTimeout(()=>mEl?.classList.remove('pulse'),1200);
  statusEl.textContent = 'Pridan√© ƒç√≠slo ' + num + ' na stranu ' + currentPage;
}
async function focusMarkerByNumber(num) {
  const m = markers.find(x => x.number===num);
  if (!m) { statusEl.textContent = 'K riadku nie je priraden√Ω marker (ƒç√≠slo: '+num+').'; return; }
  if (currentPage !== m.page) { currentPage = m.page; fitMode=null; await renderPage(); }
  fitMode=null; if (scale<FOCUS_SCALE) scale=FOCUS_SCALE; await renderPage();
  const x = m.xNorm*canvas.width, y = m.yNorm*canvas.height;
  viewer.scrollLeft = Math.max(0, Math.min(x - viewer.clientWidth/2, Math.max(0, viewer.scrollWidth - viewer.clientWidth)));
  viewer.scrollTop = Math.max(0, Math.min(y - viewer.clientHeight/2, Math.max(0, viewer.scrollHeight - viewer.clientHeight)));
  const mEl = markerLayer.querySelector(`.marker[data-number="${num}"]`); mEl?.classList.add('pulse'); setTimeout(()=>mEl?.classList.remove('pulse'),1200);
}

// ---- Viewer ----
// Naƒç√≠tanie cez tlaƒçidlo "Vybra≈• s√∫bor"
fileInput.addEventListener('change', async (e) => {
  const file = e.target.files?.[0]; if (!file) return;
  try {
    const ab = await file.arrayBuffer();
    await loadPdf(ab, file.name);
    await saveLastPdf(ab, file.name);
    statusEl.textContent = 'PDF naƒç√≠tan√© a ulo≈æen√© pre obnovu: ' + file.name;
  } catch (err) {
    console.warn('Naƒç√≠tanie/Ulo≈æenie PDF zlyhalo:', err);
    statusEl.textContent = 'PDF sa nepodarilo naƒç√≠ta≈•/ulo≈æi≈•.';
  } finally {
    fileInput.value = '';
  }
});

async function loadPdf(arrayBuffer, name = 'PDF') {
  clearViewer(); statusEl.textContent = 'Naƒç√≠tavam...';
  try { pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise; }
  catch (err) { statusEl.textContent = 'PDF sa nepodarilo naƒç√≠ta≈•: ' + err.message; console.warn(err); return; }
  pageCountEl.textContent = pdfDoc.numPages; currentPage = 1; pageNumInput.value = currentPage;
  statusEl.textContent = 'Naƒç√≠tan√©: ' + name + ' ‚Ä¢ ' + pdfDoc.numPages + ' str√°n';
  fitMode = 'window'; await renderPage(); viewer.scrollLeft=0; viewer.scrollTop=0; savePdfState();
}
function clearViewer() {
  pdfDoc=null; currentPage=1; scale=1.0; fitMode='window';
  canvas.width=0; canvas.height=0; pageCountEl.textContent='0'; pageNumInput.value=1; markerLayer.innerHTML='';
}
function clampScale(s) { return Math.max(0.2, Math.min(s, 6.0)); }
async function renderPage() {
  if (!pdfDoc) return;
  const page = await pdfDoc.getPage(currentPage);
  if (fitMode==='window') {
    const baseVp = page.getViewport({ scale:1.0 });
    const scaleW = viewer.clientWidth / baseVp.width;
    const scaleH = viewer.clientHeight / baseVp.height;
    scale = clampScale(Math.min(scaleW, scaleH));
  }
  const viewport = page.getViewport({ scale });
  canvas.width = viewport.width; canvas.height = viewport.height; canvasWrap.style.width = viewport.width + 'px';
  await page.render({ canvasContext: ctx, viewport }).promise;
  pageNumInput.value = currentPage; renderMarkers(); savePdfState();
}
prevBtn.addEventListener('click', async () => { if (!pdfDoc) return; if (currentPage>1){ currentPage--; await renderPage(); if (fitMode==='window'){ viewer.scrollLeft=0; viewer.scrollTop=0; } } });
nextBtn.addEventListener('click', async () => { if (!pdfDoc) return; if (currentPage<pdfDoc.numPages){ currentPage++; await renderPage(); if (fitMode==='window'){ viewer.scrollLeft=0; viewer.scrollTop=0; } } });
pageNumInput.addEventListener('change', async () => {
  if (!pdfDoc) return; let p=parseInt(pageNumInput.value,10); if (isNaN(p)) return;
  currentPage = Math.max(1, Math.min(p, pdfDoc.numPages)); await renderPage(); if (fitMode==='window'){ viewer.scrollLeft=0; viewer.scrollTop=0; }
});

// Lupa
function setMagnify(on) { magnifyOn=on; magnifyToggleBtn.textContent='Lupa: '+(on?'ON':'OFF'); if (on){ setHandMode(false); setAddMarkerMode(false); } }
magnifyToggleBtn.addEventListener('click', () => setMagnify(!magnifyOn));

// Pridanie ƒç√≠sla
function setAddMarkerMode(on) {
  addMarkerOn=on; addMarkerToggleBtn.textContent='Prida≈• ƒç√≠slo: '+(on?'ON':'OFF');
  viewer.classList.toggle('crosshair', on);
  statusEl.textContent = on ? 'Kliknite do PDF pre umiestnenie ƒç√≠sla.' : '';
}
addMarkerToggleBtn.addEventListener('click', () => setAddMarkerMode(!addMarkerOn));

// Klik na canvas (zoom/marker)
canvas.addEventListener('mousedown', async (e) => {
  if (!pdfDoc) return;
  if (addMarkerOn) { placeMarkerAtEvent(e); return; }
  if (!magnifyOn) return;
  if (e.button===2) e.preventDefault();
  const factor = (e.button===0) ? ZOOM_STEP : (e.button===2) ? (1/ZOOM_STEP) : 1; if (factor===1) return;
  fitMode=null;
  const rect = canvas.getBoundingClientRect(); const oldW=canvas.width, oldH=canvas.height;
  const clickXPage=(e.clientX-rect.left)/oldW; const clickYPage=(e.clientY-rect.top)/oldH;
  scale=clampScale(scale*factor); await renderPage();
  const newW=canvas.width, newH=canvas.height; const vr=viewer.getBoundingClientRect(); const vx=e.clientX-vr.left, vy=e.clientY-vr.top;
  viewer.scrollLeft = Math.max(0, Math.min(clickXPage*newW - vx, Math.max(0, viewer.scrollWidth - viewer.clientWidth)));
  viewer.scrollTop = Math.max(0, Math.min(clickYPage*newH - vy, Math.max(0, viewer.scrollHeight - viewer.clientHeight)));
});
canvas.addEventListener('contextmenu', (e) => { if (magnifyOn || addMarkerOn) e.preventDefault(); });

// Pan (ruƒçiƒçka)
let dragStart=null;
function setHandMode(on) { isHand=on; toggleHandBtn.textContent='Pan (ruƒçiƒçka): '+(on?'ON':'OFF'); viewer.classList.toggle('hand', on); viewer.classList.toggle('dragging', false); if (on){ setMagnify(false); setAddMarkerMode(false); } }
toggleHandBtn.addEventListener('click', () => setHandMode(!isHand));
viewer.addEventListener('pointerdown', (e) => {
  if (!isHand) return; viewer.setPointerCapture(e.pointerId);
  dragStart={ x:e.clientX, y:e.clientY, sl:viewer.scrollLeft, st:viewer.scrollTop }; viewer.classList.add('dragging');
});
viewer.addEventListener('pointermove', (e) => { if (!isHand || !dragStart) return; const dx=e.clientX-dragStart.x, dy=e.clientY-dragStart.y; viewer.scrollLeft=dragStart.sl-dx; viewer.scrollTop=dragStart.st-dy; });
viewer.addEventListener('pointerup', (e) => { if (!isHand) return; dragStart=null; viewer.classList.remove('dragging'); viewer.releasePointerCapture?.(e.pointerId); });

// Vycentrova≈•
centerBtn.addEventListener('click', async () => { if (!pdfDoc) return; fitMode='window'; await renderPage(); viewer.scrollLeft=0; viewer.scrollTop=0; statusEl.textContent='Zobrazen√© cel√© (vycentrovan√©).'; });

// Export/Import
const DATA_VERSION=1;
function exportData() {
  sortRowsInPlace();
  const payload={ version:DATA_VERSION, rows, markers };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='zapisnik-export.json'; a.click(); URL.revokeObjectURL(url);
  statusEl.textContent='Export hotov√Ω.';
}
async function importData(file) {
  try {
    const text=await file.text(); const data=JSON.parse(text);
    if (!data || !Array.isArray(data.rows) || !Array.isArray(data.markers)) { alert('Neplatn√Ω form√°t importu.'); return; }
    if (!confirm('Import nahrad√≠ existuj√∫ce riadky a markery. Pokraƒçova≈•?')) return;
    rows = data.rows.map(r=>({...r})); sortRowsInPlace(); saveRows();
    markers = data.markers.map(m=>({ number:parseInt(m.number,10), page:parseInt(m.page,10), xNorm:Number(m.xNorm), yNorm:Number(m.yNorm) }))
      .filter(m=>!isNaN(m.number)&&!isNaN(m.page)&&isFinite(m.xNorm)&&isFinite(m.yNorm));
    saveMarkers(); renderRows(); renderMarkers();
    statusEl.textContent='Import hotov√Ω. (Uistite sa, ≈æe pracujete s rovnak√Ωm PDF.)';
  } catch (err) { alert('Import zlyhal: '+err.message); }
  finally { importDataInput.value=''; }
}
exportBtn.addEventListener('click', exportData);
importBtn.addEventListener('click', () => importDataInput.click());
importDataInput.addEventListener('change', async (e) => { const file=e.target.files?.[0]; if (file) await importData(file); });

// Panel ‚Äì presn√° ≈°√≠rka + r√∫ƒçka
function updatePanelWidthVar() { const w=sidePanel.getBoundingClientRect().width; document.body.style.setProperty('--side-open-w', w+'px'); }
function updatePanelHandleIcon() { panelHandleBtn.textContent = panelOpen ? '‚Ä∫' : '‚Äπ'; panelHandleBtn.setAttribute('aria-expanded', String(panelOpen)); }
function setPanelOpen(on) {
  panelOpen=on; sidePanel.classList.toggle('open', on); document.body.classList.toggle('panel-open', on); updatePanelHandleIcon();
  if (on) { requestAnimationFrame(updatePanelWidthVar); window.addEventListener('resize', updatePanelWidthVar); }
  else { window.removeEventListener('resize', updatePanelWidthVar); document.body.style.removeProperty('--side-open-w'); }
  if (pdfDoc && fitMode==='window') { renderPage(); viewer.scrollLeft=0; viewer.scrollTop=0; }
}
panelHandleBtn.addEventListener('click', () => setPanelOpen(!panelOpen));

// DOH kalkulaƒçka
const dohOpenBtn=document.getElementById('dohOpen');
const dohOverlay=document.getElementById('dohOverlay');
const dohCloseBtn=document.getElementById('dohClose');
const dohInventoryInput=document.getElementById('dohInventory');
const dohPerfPeriodInput=document.getElementById('dohPerfPeriod');
const dohWdaysPerWeekInput=document.getElementById('dohWdaysPerWeek');
const dohCalcBtn=document.getElementById('dohCalc');
const dohClearBtn=document.getElementById('dohClear');
const dohResultEl=document.getElementById('dohResult');
const dohErrorEl=document.getElementById('dohError');
const dohNoteEl=document.getElementById('dohNote');
const DOH_PREFS_KEY='dohCalcPrefs';
function getSelectedDays(){ const r=document.querySelector('input[name="dohDays"]:checked'); return r?parseInt(r.value,10):30; }
function getResultType(){ const r=document.querySelector('input[name="dohResultType"]:checked'); return r?r.value:'work'; }
function openDoh(){ loadDohPrefs(); dohOverlay.hidden=false; setTimeout(()=>dohInventoryInput.focus(),0); }
function closeDoh(){ dohOverlay.hidden=true; }
function loadDohPrefs() {
  try {
    const raw=localStorage.getItem(DOH_PREFS_KEY); if (!raw) return; const p=JSON.parse(raw);
    document.querySelector(`input[name="dohDays"][value="${p.days===360?360:30}"]`).checked=true;
    const rt=document.querySelector(`input[name="dohResultType"][value="${p.resultType||'work'}"]`); rt && (rt.checked=true);
    if (typeof p.wdaysPerWeek==='number') dohWdaysPerWeekInput.value=p.wdaysPerWeek;
    if (typeof p.inventory==='number') dohInventoryInput.value=p.inventory;
    if (typeof p.perfPeriod==='number') dohPerfPeriodInput.value=p.perfPeriod;
  } catch {}
}
function saveDohPrefs(){
  const payload={ days:getSelectedDays(), resultType:getResultType(), wdaysPerWeek:parseFloat(dohWdaysPerWeekInput.value), inventory:parseFloat(dohInventoryInput.value), perfPeriod:parseFloat(dohPerfPeriodInput.value) };
  localStorage.setItem(DOH_PREFS_KEY, JSON.stringify(payload));
}
function fmtDays(val){ if(!isFinite(val)) return '‚àû'; return (Math.round(val*100)/100).toLocaleString('sk-SK')+' d≈àa'; }
function showError(msg){ dohErrorEl.textContent=msg; dohErrorEl.hidden=false; }
function clearError(){ dohErrorEl.hidden=true; dohErrorEl.textContent=''; }
function clampNum(v,min,max){ return Math.max(min, Math.min(max,v)); }
function computeDoh(){
  clearError();
  const inv=Number(dohInventoryInput.value), perfPeriod=Number(dohPerfPeriodInput.value), days=getSelectedDays(), resultType=getResultType();
  const wdaysPerWeek=clampNum(Number(dohWdaysPerWeekInput.value)||5,1,7), wRatio=wdaysPerWeek/7;
  if (!isFinite(inv)||inv<0){ showError('Zadaj platn√∫ hodnotu skladu (nez√°porn√© ƒç√≠slo).'); return; }
  if (!isFinite(perfPeriod)||perfPeriod<=0){ showError('Zadaj platn√Ω v√Ωkon za obdobie (kladn√© ƒç√≠slo).'); return; }
  const dohCal=(inv*days)/perfPeriod, dohWork=(inv*(days*wRatio))/perfPeriod, dohDays=(resultType==='work')?dohWork:dohCal;
  dohResultEl.textContent='V√Ωsledok: '+fmtDays(dohDays);
  statusEl.textContent='DOH vypoƒç√≠tan√Ω: '+dohDays.toFixed(2)+(resultType==='work'?' pracovn√©ho d≈àa':' kalend√°rneho d≈àa');
  const dailyCogsCal=perfPeriod/days, dailyCogsWork=perfPeriod/(days*wRatio);
  dohNoteEl.textContent='Odvoden√© denn√© COGS ‚Üí kalend√°rne: '+Math.round(dailyCogsCal).toLocaleString('sk-SK')+' ‚Ç¨/de≈à, pracovn√©: '+Math.round(dailyCogsWork).toLocaleString('sk-SK')+' ‚Ç¨/prac. de≈à.';
  saveDohPrefs();
}
dohOpenBtn.addEventListener('click', openDoh);
dohCloseBtn.addEventListener('click', closeDoh);
dohOverlay.addEventListener('click', (e)=>{ if(e.target===dohOverlay) closeDoh(); });
dohCalcBtn.addEventListener('click', computeDoh);
dohClearBtn.addEventListener('click', ()=>{ dohInventoryInput.value=''; dohPerfPeriodInput.value=''; dohResultEl.textContent='V√Ωsledok: ‚Äî'; dohNoteEl.textContent=''; clearError(); saveDohPrefs(); });
document.querySelectorAll('input[name="dohDays"]').forEach(r=>r.addEventListener('change', saveDohPrefs));
document.querySelectorAll('input[name="dohResultType"]').forEach(r=>r.addEventListener('change', saveDohPrefs));
dohWdaysPerWeekInput.addEventListener('input', saveDohPrefs);
[dohInventoryInput, dohPerfPeriodInput].forEach(inp=>inp.addEventListener('keydown',(e)=>{ if(e.key==='Enter') computeDoh(); }));
document.addEventListener('keydown',(e)=>{ if(e.key==='Escape' && !dohOverlay.hidden) closeDoh(); });

// Inicializ√°cie
loadRows(); renderRows(); loadMarkers(); renderMarkers(); if (rows.length===0) addEmptyRow();
setPanelOpen(false); updatePanelHandleIcon();

// Obnova PDF po naƒç√≠tan√≠ (window.name -> sessionStorage -> localStorage -> IndexedDB)
window.addEventListener('load', async () => {
  try {
    statusEl.textContent = 'Obnovujem posledn√© PDF...';
    const rec = await loadLastPdfRecord();
    if (rec && rec.arrayBuffer) {
      await loadPdf(rec.arrayBuffer, rec.name || 'PDF');
      const st=loadPdfState();
      if (st && pdfDoc) {
        if (Number.isInteger(st.page)) currentPage = Math.max(1, Math.min(st.page, pdfDoc.numPages));
        if (typeof st.scale==='number') { scale=clampScale(st.scale); fitMode=st.fitMode||null; }
        await renderPage();
      }
      statusEl.textContent = 'Obnoven√©: ' + (rec.name || 'PDF') + ' ‚Ä¢ ' + pdfDoc.numPages + ' str√°n';
    } else {
      statusEl.textContent = 'Vyberte PDF s√∫bor (tlaƒçidlo hore vƒæavo).';
    }
  } catch (e) {
    console.warn('Obnova PDF po naƒç√≠tan√≠ zlyhala:', e);
    statusEl.textContent = 'Vyberte PDF s√∫bor (tlaƒçidlo hore vƒæavo).';
  }
});
</script>
